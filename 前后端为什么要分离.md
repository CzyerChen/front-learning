> 前后端为什么要分离？有什么问题？怎么分离？
> 很多人或许都知道，分而治之，当然大家可以各做各的，效率比较高，不过这还真的不容易
> 学习了一波[淘宝前后端分离的PPT](https://2014.jsconfchina.com/slides/herman-taobaoweb/index.html#/)

### 前后端为什么要分离？
- 很久之前，我们的页面总是和后端代码一起的；
- 几种情况：
```text
1. 几位大哥单干，你做几个页面，我做几个页面，可是规范不一样啊，甚至说有的大哥没有规范，自己随意写，这种人的规范如果不是硬性规定，是很难统一的，大家都觉得自己这样写挺好

2. 几位大哥一起干，你做前端，我写后端，那就是前端的风格稳定了，后端的风格也稳定了，可是在一个项目里面，如果用了统一的代码仓库，就会出现谁的代码要是提交的不恰当，别人相关的代码都跑不起来

```
- 因而，如果前后端不分离，人的职能会很混乱，就像第一种情况，大家前后端都做，并且风格都不一致，当然也会是一直boss提倡的 "全栈"，一人包办
- 或者就是职能分离但是代码不分离，代码就会很混乱，像第二种情况

### 互联网时代，前后端分离有什么问题？
- 无法有统一的协作模式，前后端之前充满了约定
- 前端代码越来越复杂，后端数据依赖于前端的展示，会有很多VO的对象
- 前端也局限于后端的接口，控制取决于后端返回的html,有数据来源于ajax或者数据映在dom上
- 有些业务逻辑也需要在前端完成，有的在Model 有的在View
- 前端依赖后端的开发环境，后端与view层的数据耦合较大
- 另外就是前后端的沟通成本大
- 我们目前能够看到，很多前端框架，可能都是在一个方面，比如web或者安卓方面支持较好，跨终端的控制并不好

#### view层是一个衔接层，也是一个尴尬层
- view交给前端，前端就需要了解后端接口层的一些基础知识
- view交给后端，后端就需要书写HTML，了解前端的知识，并且前端仍然是要确认后端HTML

### 第一次前后端分离
- 后端负责处理数据，以及数据相关的逻辑
- 前端model层，通过js获取数据，暂存数据，view层，通过模板渲染获取的数据（Backbone, EmberJS, KnockoutJS, AngularJS, React, etc.）
- 这样也就出来了，当下一般在使用套路（WEB SERVICE）
```text
后端职责：
1. 提供数据
2. 处理业务逻辑
3. server side MVC 架构
4. 代码在服务器上

前端职责：
1. 接受数据，返回数据
2. 渲染数据
3. client side MV* 架构
4. 代码在浏览器上 

```
- 但是这也是有问题： 
比如职能重叠
```text
Client-side Model 是 Server-side Model 的加工
Client-side View 跟 Server-side是 不同层次的东西
Client-side的Controller 跟 Sever-side的Controller 各搞各的
Client-side的Route 但是 Server-side 可能没有
```
性能问题：
```text
渲染，取值都在客户端进行，有性能的问题
需要等待资源到齐才能进行，会有短暂白屏与闪动
在移动设备低速网路的体验奇差无比
```
重用问题：
```text
模版无法重用，造成维护上的麻烦与不一致
逻辑无法重用，前端的校验后端仍须在做一次
路由无法重用，前端的路由在后端未必存在
```
跨终端问题：
```text
业务太靠前，导致不同端重复实现
逻辑太靠前，造成维护上的不易
```
SEO问题：
```text
渲染都在客户端，模版无法重用，SEO实现麻烦
```
### 第二次前后端分离
- 分离前后端的标准或许不同，但是无非硬件层面（比如，作用在浏览器，作用在服务器）、工作职责（比如，处理数据，处理页面渲染）
- 拿node Js看前后端的定义：
```text
后端      --------------->    前端    ---------------> 前端
 
JAVA                         Node JS ------网络----> Brower

```
- 那么连淘宝都推荐的Node JS到底有什么威力呢？
```text
前端熟悉，那么学习成本低
由于都是JS, 那么前后端都可以复用
事件驱动，非阻塞的IO
适合IO密集型业务

```
- 职责划分
```text
    后端                    前端
-----------------------------------------------------------
            服务器                    浏览器
-----------------------------------------------------------
   JAVA               NodeJs           js + html + css
-----------------------------------------------------------
服务层               服务器上的JS        浏览器上的JS 
数据接口             转发数据            CSS JS 加载运行
数据稳定性           控制路由            DOM操作
封装业务逻辑         渲染页面            前端框架，模板，路由
```
### node可以协作做的优化
- 首页加载缓存、定时刷新优化：node可以容许页面缓存和定时刷新，可以比以前有更好的用户体验，NodeJS产出静态页面到CDN，定时刷新
- 详情数据的优化：单日数据量巨大，详情页数据需要从不同接口和数据库拼接，可以使用Bigpiper技术，合并请求，降低负担，分批输出，不影响体验
- 接口优化：大接口-> 小接口，串行->并行，异步请求
- 部署优化：一台NodeJS对多台JAVA服务器， 合理的分配服务器带来最大的产出
- 页面渲染优化：前后端共享模版、首屏服务器渲染、次屏浏览器渲染、局部刷新浏览器渲染
- 单页面应用优化：前后端共享路由与模版，前端换页，浏览器端渲染，直接输入网址，服务器渲染，SEO问题迎刃而解
- 可靠性优化：单元测试，页面测试，回归测试，持续集成

### 具体改造 - 接口服务化
- 基于Json Schema
- 增强请求与返回的条件描述
- 扩展format
- 接口管理平台
```text
自动化文档管理
版本管理
应用发布：支持灰度和回滚
接口验证：格式和回归测试

```
- 接口模拟：
```text
查看模拟数据，符合接口定义
前端不需要依赖后端的正确数据，可以自行开大
模拟数据可以模拟边界值和错误值，能够辅助前端做完整的测试
减少前后端的耦合
```
- 模块支持
```text
node JS能够提供不同的接口（HTTP MYSQL）
Data Proxy 能够只负责数据通信
```


### 具体改造 - 代码模块化
- 前后端复用
- 模块预处理

### 具体改造 - 功能组件化
- 把细粒度的模块封装成应付业务需求的组件
- 然后结合不同的组件，进行组合，实现不同的功能
- 多型
```text
针对不同环境，单一组件 可具备 不同型态

同一组件在不同环境下可以有不同的行为


例如一个地址选择器
在不同的设备：pc, mobile, pad, tv
不同的环境：browser, native app, hybrid app上

有著不一样的呈现结构，不一样的交互方式。
但有著一样的校验逻辑，共用同样的数据接口

封装适合的组件。不同的场景组合不同的结果，透过多型机制正确的输出

```

### 具体改造 - 框架化
